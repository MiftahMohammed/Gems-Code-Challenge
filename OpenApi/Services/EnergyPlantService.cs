using OpenApi.Contracts;
using OpenApi.Helpers;
using OpenApi.Models;

namespace OpenApi.Services
{
    public class EnergyPlantService : IEnergyPlantService
    {
        //Can be modified
        const double GasCo2TonsPerMWh = 0.42;
        const double KerosineCo2TonsPerMWh = 8.9;

        public List<PlantHelper> GetProductionPlan(GetProductionPlanRequest request)
        {
            //Assumptions:
            // we assume that MinPower is propotional to MaxPower for all plants, i.e: if plant1.maxPower > plant2.maxPower
            // the of course plant1.minPower > plant2.minPower. otherwise it would become more complex.

            List<PlantHelper> plantOutputPowers = new List<PlantHelper>();

            var plantsCosts = new Dictionary<PlantHelper, double>();
            foreach (var plant in request.PowerPlants)
            {
                plantsCosts.Add(new PlantHelper(plant, request.Fuels.WindPercent), GetMWhCost(plant, request.Fuels));
            }

            var orderdByCostThenMaxPowerDesc = plantsCosts.OrderBy(x => x.Value)
                                                            .ThenByDescending(x => x.Key.Efficiency)
                                                            .ThenBy(x => x.Key.MaxPower);

            double remainingPower = request.Load;
            foreach (var item in orderdByCostThenMaxPowerDesc)
            {
                if (remainingPower == 0)
                {
                    item.Key.ProducedPower = 0;
                    plantOutputPowers.Add(item.Key);
                    continue;
                }

                if (remainingPower < item.Key.OutputMinPower)
                {
                    item.Key.ProducedPower = item.Key.OutputMinPower;
                    plantOutputPowers.Add(item.Key);
                    remainingPower = 0;
                }
                else if (remainingPower > item.Key.OutputMinPower && remainingPower <= item.Key.OutputMaxPower)
                {
                    item.Key.ProducedPower = remainingPower;
                    plantOutputPowers.Add(item.Key);
                    remainingPower = 0;
                }
                else
                {
                    item.Key.ProducedPower = item.Key.OutputMaxPower;
                    plantOutputPowers.Add(item.Key);
                    remainingPower -= item.Key.OutputMaxPower;
                }
            }

            //in case the min required power from the next plant is less then the reel Min power
            // then we should decrease the production of the previous plants to reduce the cost/losses and
            //produce exactly the required load (in ideal case, there are no other losses: transport losses, resistance...Etc)
            AdaptPreviousPlants(plantOutputPowers, request.Load, request.Fuels.WindPercent);

            return plantOutputPowers;
        }

        private void AdaptPreviousPlants(List<PlantHelper> plantOutputPowers, double load, double windPercent)
        {
            var rslt = new GetProductionPlanResponse();

            //check the extra power generated by all plans until now
            double extraPower = plantOutputPowers.Sum(x => x.ProducedPower) - load;

            if (extraPower > 0)
            {
                //means that the last plant is running at minimum power, and we still produce moe the required
                //we should decrease the previous plant powers output.
                var lastPlantIndex = plantOutputPowers.FindLastIndex(x => x.ProducedPower > 0);
                for (int i = lastPlantIndex - 1; i >= 0; i--)
                {
                    // PS: here the ProducedPower == OutputMaxPower
                    plantOutputPowers[i].ProducedPower -= extraPower;
                    if (plantOutputPowers[i].ProducedPower <= 0)
                    {
                        //in this case no need to turn on this plant
                        plantOutputPowers[i].ProducedPower = 0;
                    }
                    else if (plantOutputPowers[i].ProducedPower < plantOutputPowers[i].OutputMinPower)
                    {
                        plantOutputPowers[i].ProducedPower = plantOutputPowers[i].OutputMinPower;
                    }

                    //re-calculate the extra power
                    extraPower = plantOutputPowers.Sum(x => x.ProducedPower) - load;
                }
            }
        }

        private double GetMWhCost(PlantInfo plantInfo, Fuels fuels)
        {
            double fuelPrice;
            if (plantInfo.Type == PlantType.GasFired)
            {
                fuelPrice = fuels.Gas + GasCo2TonsPerMWh * fuels.Co2;
            }
            else if (plantInfo.Type == PlantType.TurboJet)
            {
                fuelPrice = fuels.Kerosine + KerosineCo2TonsPerMWh * fuels.Co2;
            }
            else
            {
                fuelPrice = 0;
            }

            return fuelPrice;
        }
    }
}
